# 回溯算法
可以大概类比成枚举算法，找到所有满足条件的解。地毯式搜索。也是动态规划思想的基础。

回溯思想相关问题非常适合用递归来实现。一般一个递归函数都会有多个递归，

不满足条件的情况，递归函数自动因为判断条件退出，
满足的情况会继续递归下去，直到找到所有解。

采用递归解法有两点

* 第一点 终止条件 

    带有最优解得一般还会更新最优解
    递归结束条件

* 第二点 问题的状态以及后续的选择

    问题状态和选择决定了递归参数，递归条件

* 第三点 剪枝 

    满足解后及时终止其它递归

## 典型问题
### 8皇后问题

```
每一行共有8种放置可能，总共有8列。
第一行 for i := range 每列8个位置
    判断是否满足条件 (当前行依次往上判断是否满足之前放置的位置)
        true 递归第二行
```

#### 终止条件

当行数等于8时候，代表最后一行也满足所有条件，记录满足的值并返回。

#### 状态&选择

状态是当前行数

选择是当前位置是否满足条件，以及满足条件层数加一继续递归。


#### 剪枝

无

因为没有最优解，需要遍历所有可能

### 0-1背包

背包总的承载重量是100kg。有10个物品，分别是a[]重量。在不超过总重量前提下，尽可能多装

分析

```
每个物品都有两个选择，装或者不装，利用回溯思想，在总量不超情况下递归枚举出所有情况。

    判断是否退出
        不装当前物品
        if 加上当前物品小于等于总共物品
            装当前物品
```

#### 终止条件

背包已满或者所有物品都已经放入，返回。

当当前总量大于于记录最大重量，更新最大重量。

#### 状态&选择

状态是当前背包重量以及背包里物品数量。

选择是装当前物品或者不装

#### 剪枝

判断只有加上当前物品小于等于总共物品，才选择装当前物品

### 正则表达式

正则表达式 思路和背包相同。

遇到非通配符，直接比较，遇到通配符，比如多种方案的通配符，先选择一个继续往下递归，直到匹配成功。

或者匹配失败，再继续选择下一个方案继续。直到字符串匹配完。

#### 终止条件

正则表达式匹配结束，返回

如果匹配字符串也结束代表匹配成功。

#### 状态&选择

状态是当前正则表达式，和当前匹配字符串。

选择是特色匹配规则逻辑，例如"*"代表所有字符串，遍历当前往后的匹配字符串

"?"代表选择不匹配或者匹配一个任意字符串，

其它字符就是判断是否相等。

#### 剪枝

如果当前正则不是特殊匹配字符，先判断匹配字符串是否到头，

只有未到头才会继续递归下一个。